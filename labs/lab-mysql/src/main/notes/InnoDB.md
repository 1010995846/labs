## 读写
InnoDB处理数据的过程是发生在内存中的，需要把磁盘中的数据加载到内存中，如果是处理写入或修改请求的话，还需要把内存中的内容刷新到磁盘上。

读写磁盘的速度非常慢，和内存读写差了几个数量级，所以当我们想从表中获取某些记录时，InnoDB存储引擎将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小默认为 16 KB。也就是在一般情况下，一次最少从磁盘中读取16KB的内容到内存中，或者一次最少把内存中的16KB内容刷新到磁盘中。

show variables like 'innodb_page_size';

注意：innodb_page_size变量在服务器运行过程中不可以更改，只能在第一次初始化MySQL数据目录时指定。所以页在运行时的大小不可更改。


## 行格式
我们平时是以记录为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为行格式或者记录格式。行格式有4种，分别是Dynamic、Compact、Redundant和Compressed。
show variables like 'innodb_default_row_format';


### dynamic-默认行格式。

![dynamic](picture\dynamic.jpg)

#### 变长字段长度列表

关于记录的额外信息这部分，是服务器为了描述这条记录而不得不额外添加的一些信息，这些额外信息分为3类，分别是变长字段长度列表、NULL值列表和记录头信息。

一些变长的数据类型，比如VARCHAR(M)、各种TEXT类型，各种BLOB类型，变长数据类型的字段中存储多少字节的数据是不固定的，在存储真实数据的时候需要把这些数据占用的字节数也存起来。

就像设计String类型，不仅仅是存放真实数据的char数组，还有length变量去记录字符串长度。又比如input输入框最大限制500字，但是你还得有一个变量去统计真实在输入框内有多少字符。同理，varchar也有记录真实数据长度的变量（假设为L，后文沿用方便描述），L表示varchar真实占用的字节数，innodb最多分配2个字节去表示这个L，就像`unsigned short`类型，2个字节，寄存器最多只有16位来让你存这个长度，所以L记录范围是`2^16 - 1 = 65535`字节，实际长度根据编码占用字节判断。

这些变长字段(比如varchar)占用的存储空间分为两部分：

- 真正的数据内容部分，放在对应的列
- 真实占用的字节数，放在变长字段列表部分

> 变长字段列表只存储非NULL的列的长度。

#### NULL值列表

如果表中的某些列可能存储NULL值，把这些NULL值都放到记录的真实数据中存储会很占地方，所以dynamic行格式把这些值为NULL的列统一管理起来，存储到NULL值列表中，它的处理过程是这样的：

1.统计表中允许存储NULL的列有哪些。

主键列、被NOT NULL修饰的列都是不可以存储NULL值的，所以在统计的时候不会把这些列算进去。比方说表test的3个列c1、c3、c4都是允许存储NULL值的，而c2列是被NOT NULL修饰，不允许存储NULL值。

2.如果表中没有允许存储 NULL 的列，则 NULL值列表也不存在了，否则将每个允许存储NULL的列对应一个二进制位，二进制位按照列的顺序逆序排列。二进制位的值为1时，代表该列的值为NULL，为0时，代表该列的值不为NULL。

3.NULL值列表必须用整数个字节的位表示，如果使用的二进制位个数不足整数个字节，则在字节的高位补0。

例：如果表中有9个字段都允许为NULL，那么这个记录的NULL值列表就需要2个字节来表示，靠前的6个高位补0。

#### 溢出列

如果某个列中存储的数据占用的字节数非常多，该列就可能称为溢出列。

对于占用存储空间非常多的列，在记录真实数据时，该列只会用20字节空间，而这20字节的空间不存储数据，因为数据都分散存储在其他几行中了。这20字节的空间存储的是分散行的地址和占用的字节数。分散行记录是单链表连接的结构。

@import "https://raw.githubusercontent.com/shd101wyy/markdown-preview-enhanced/master/LICENSE.md"

@import "字段类型_varchar.md"

@import "picture\dynamic.jpg"


